/**
 * Delegate client.
 *
 * @module core/delegate
 */

'use strict';

const keccak256  = require('keccak256');
const math       = require('lib/math');
const evt        = require('lib/events');
const Account    = require('core/account');
const tp         = require('core/transport');
const chain      = require('core/db').chain;
const waiter     = require('services/waiter');
const peer       = require('core/file-peer');
const parseState = require('lib/block-state');
const me         = require('services/wallet');

const conf = require('lib/constants');

// NOTE Random number distribution.
//
// 1. When random number is generated
// it must be sent as an object and it must
// have a signature of delegate who generated it.
//
// 2. Each delegate receiving random number from
// other fellow delegate must verify a signature.
//
// 3. Each delegate must verify that no more than
// one random number is generated by each delegate.
//
// 4. Random number must be generated only once in a round.

/**
 * Delegates multicast channel. Currently it's all.
 *
 * @todo separate delegates communication channel.
 * @type {String}
 */
const DELEGATES  = '*';

/**
 * Number of ms to wait to receive other delegates' randoms.
 * @type {Number}
 */
const WAIT_TIME = conf.DELEGATE_WAIT_TIME || 3000;

/**
 * Attach event listeners to current transport.
 */
exports.attach = function attach() {

    tp.on(evt.START_ROUND, exchangeRandoms);
};

/**
 * Detach event listeners from current transport.
 */
exports.detach = function detach() {

    tp.off(evt.START_ROUND, exchangeRandoms);
};

/**
 * Do generate final random number and broadcast it to network using following steps:
 *
 * - send random number to DELEGATES group
 * - wait for 32 random numbers from other delegates
 * - calculate final random number using all 33 randoms
 * - send final random to DELEGATES group
 * - wait for 32 final randoms from other delegates
 * - broadcast final random value to network when at least 17 delegates agree on final random
 * - when consensus has not been reached - repeat these steps again after timeout
 *
 * @listens events.START_ROUND
 *
 * @emits events.RND_EVENT
 * @emits events.FRND_EVENT
 * @emits events.BP_CATCH_IT
 *
 * @return {Promise}
 */
async function exchangeRandoms() {

    // Get current block first
    const currentBlock = await chain.getLatest();
    const state        = parseState(currentBlock.state);
    const delegates    = state.delegates;

    // Start the delegate part
    // 1. Generate and stream randmo number over network
    const myRandom  = math.random();
    const msgToSend = {
        random:    myRandom,
        publicKey: me.publicKey.toString('hex'),
        signature: me.signMessage(myRandom).toString('hex')
    };

    const resPromise = waiter.collect(evt.RND_EVENT, WAIT_TIME);

    tp.send(evt.RND_EVENT, msgToSend, DELEGATES);

    // Message sent, other delegates did the same job
    // 2. Wait for same action to be done by other delegates
    const randomNumbers = (await resPromise)
        .map((msg)    => msg.data)
        .filter((msg) => delegates.includes(Account.publicKeyToAddress(msg.publicKey)))
        .filter((msg) => Account.verifyMessage(msg.random, Buffer.from(msg.publicKey, 'hex'), Buffer.from(msg.signature, 'hex')))
        .map((msg)    => +msg.random);

    // QUESTION: What should we do when number of ACTIVE_DELEGATES has not been reached?
    // QUESTION: How do we sort delegates and fill missing from successors?
    // QUESTION: How to test setups when there's only runner X count? We'd have to run some test-ready setting.
    // if (randomNumbers.length < conf.ACTIVE_DELEGATES_COUNT) { }

    const finalRandomNum = math.finalRandom(randomNumbers);
    const fresPromise    = waiter.collect(evt.FRND_EVENT, 1000); // Collect FRN for a second

    tp.send(evt.FRND_EVENT, finalRandomNum, DELEGATES);

    const finalResponses = await fresPromise;
    const resolution     = math.votingResults(finalResponses.map((r) => r.data));
    const finalRandom    = resolution[0].value;

    console.log('Voting results are: ', finalRandom);
    console.log('Other results for FRN: ', resolution);

    if (resolution[0].count <= Math.floor(finalResponses.length / 2)) {

        // QUESTION: what should we do programmatically when round is unsucceful?
        // I mean should we restart everything? Or only this function? Consensus to re-roll
        // has to be reached somehow. Think about it

        console.log('Round unsucceful, retrying in 2 seconds');

        return waiter.wait(2000).then(exchangeRandoms);
    }

    console.log('Round successors, streaming: %s', finalRandom);

    tp.send(evt.BP_CATCH_IT, finalRandom, '*');

    // X. Wait for producer to produce block (but also verify incoming blocks)
    const nextProducer = math.findProducer(finalRandom, state.blockProducers);
    const peerData     = await waiter.waitForCond(evt.VERIFY_BLOCK, ({publicKey}) => {
        return (Account.publicKeyToAddress(publicKey) === nextProducer);
    }, 2000);

    console.log('Verifying received block');

    const address = peerData.meta.address;
    const port    = peerData.data.port;
    const block   = await peer.pullString(address, port).then(JSON.parse).catch(console.error);

    if (!block || !isValidBlock(block, currentBlock)) {
        return console.log('Block is invalid!');
    }

    console.log('Streaming block over the network');

    return streamBlock(block);
}

/**
 * Validate block.
 *
 * @param  {Object}           producedBlock Block produced by BP.
 * @return {Promise<Boolean>}               Whether block is valid or not.
 */
async function isValidBlock(producedBlock, parentBlock) {
    const block = me.produceBlock(parentBlock, producedBlock.transactions);

    return (producedBlock.stateRoot    === block.stateRoo)
        && (producedBlock.receiptsRoot === block.receiptsRoot);
}

/**
 * Stream verified block over network using HTTP-peering.
 *
 * @todo create Block type definition somewhere
 *
 * @emits evt.NEW_BLOCK
 *
 * @param  {Block}   block Block to stream over network.
 * @return {Promise}       Promise that ends with peering result or null when 0 nodes were online.
 */
async function streamBlock(block) {
    const nodesCount = 5 + tp.knownNodes.size;

    // QUESTION - need to rethink this function - rn it's unclear what's happening
    // ALSO - decide something about signatures from delegates and include them into block

    // If there's no one to share - why bother?
    if (nodesCount === 0) {
        return null;
    }

    const {port, promise} = peer.peerString(block, nodesCount, 5000);
    const hashedBlock     = keccak256(JSON.stringify(block)).toString('hex');
    const signature       = me.signMessage(hashedBlock).toString('hex');
    const publicKey       = me.publicKey.toString('hex');

    const otherSinatures  = waiter.collect(evt.BLOCK_SIG, 1000);

    tp.send(evt.BLOCK_SIG, {
        port,
        hashedBlock,
        publicKey,
        signature
    }, DELEGATES);

    const signatures = (await otherSinatures).map((msg) => msg.data);

    // const numDelegates     = 1 || 33;
    // const responses        = await waiter.waitForAll(evt.BLOCK_SIG, numDelegates, Infinity);
    // const responseMessages = responses.map((r) => r.data);
    // const verifiedMessages = responseMessages.filter(msg => Account.verifyMessage(msg.hashedBlock, Buffer.from(msg.publicKey, 'hex'), Buffer.from(msg.signature, 'hex')));
    // const verifiedBlocks   = verifiedMessages.map(msg => msg.hashedBlock);
    //
    // console.log('Verified blocks:', verifiedBlocks);
    //
    // if (verifiedBlocks.length < numDelegates) {
    //     // TODO Case when not enough delegates verified block.
    //     console.log('VERIFIED < NUMBER OF DELEGATES');
    // }

    tp.send(evt.NEW_BLOCK, {
        port,
        block: {
            number:     block.number,
            hash:       block.hash,
            parentHash: block.parentHash,
            random:     block.randomNumber,
            producer:   block.producer
        },
        publicKey,
        signatures
    });

    return promise;
}
